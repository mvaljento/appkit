import{disconnect as d,getAccount as u,watchAccount as w,fetchBalance as C,getNetwork as m,watchNetwork as p,switchNetwork as f,fetchEnsName as g,fetchEnsAvatar as v,connect as h,InjectedConnector as y}from"@wagmi/core";import{WalletConnectConnector as I}from"@wagmi/connectors/walletConnect";import{WalletConnectLegacyConnector as W}from"@wagmi/core/connectors/walletConnectLegacy";import{jsonRpcProvider as E}from"@wagmi/core/providers/jsonRpc";const P="wallet_addEthereumChain";class L{constructor(n,t){this.wagmi={},this.walletConnectVersion=1,this.chains=[],this.namespace="eip155",this.disconnect=d,this.getAccount=u,this.watchAccount=w,this.fetchBalance=C,this.getNetwork=m,this.watchNetwork=p,this.switchNetwork=f,this.fetchEnsName=g,this.fetchEnsAvatar=v,this.wagmi=n,this.chains=t;const{isV2:e}=this.getWalletConnectConnectors();this.walletConnectVersion=e?2:1}getWalletConnectConnectors(){const n=this.wagmi.connectors.find(o=>o.id==="walletConnect"),t=this.wagmi.connectors.find(o=>o.id==="walletConnectLegacy"),e=n??t;if(!e)throw new Error("WalletConnectConnector or WalletConnectLegacyConnector is required");return{isV2:!!n,connector:e}}async connectWalletConnectV1(n,t){return new Promise((e,o)=>{n.once("message",async({type:i})=>{if(i==="connecting"){const c=(await n.getProvider()).connector;t(c.uri),c.on("disconnect",()=>{o(Error())}),c.on("connect",()=>{e()})}})})}async connectWalletConnectV2(n,t){return await n.getProvider(),new Promise(e=>{n.once("message",o=>{o.type==="display_uri"&&(t(o.data),e())})})}getConnectorById(n){const t=this.wagmi.connectors.find(e=>e.id===n);if(!t)throw new Error(`Connector for id ${n} was not found`);return t}getConnectors(){return this.wagmi.connectors.filter(n=>!n.id.includes("walletConnect"))}async connectWalletConnect(n,t){const{connector:e,isV2:o}=this.getWalletConnectConnectors(),i={connector:e};t&&(i.chainId=t);const c=o?this.connectWalletConnectV2.bind(this):this.connectWalletConnectV1.bind(this);return Promise.all([h(i),c(e,n)])}async connectConnector(n,t){const e={connector:this.getConnectorById(n)};return t&&(e.chainId=t),await h(e)}isInjectedProviderInstalled(){return typeof window.ethereum<"u"}safeCheckInjectedProvider(n){var t;try{const e=String(n);return!!((t=window.ethereum)!=null&&t[e])}catch(e){return console.error(e),!1}}async getConnectedChainIds(){var n,t,e;const{connector:o,isV2:i}=this.getWalletConnectConnectors();if(i){const c=(t=(n=(await o.getProvider()).signer)==null?void 0:n.session)==null?void 0:t.namespaces,l=(e=c?.[this.namespace])==null?void 0:e.methods;if(l!=null&&l.includes(P))return"ALL";if(c){const a=[];return Object.keys(c).forEach(s=>{s.includes(this.namespace)&&a.push(...c[s].accounts)}),a?.map(s=>s.split(":")[1])}}return"ALL"}}const k="eip155";function b({projectId:r}){return E({rpc:n=>{var t;return[1,3,4,5,10,42,56,69,97,100,137,280,324,420,42161,42220,43114,80001,421611,421613,1313161554,1313161555].includes(n.id)?{http:`https://rpc.walletconnect.com/v1/?chainId=${k}:${n.id}&projectId=${r}`}:{http:n.rpcUrls.default.http[0],webSocket:(t=n.rpcUrls.default.webSocket)==null?void 0:t[0]}}})}function B({chains:r,version:n,projectId:t}){const e=n===1,o=[new y({chains:r})];return e?o.unshift(new W({chains:r,options:{qrcode:!1}})):o.unshift(new I({chains:r,options:{projectId:t,showQrModal:!1}})),o}export{L as EthereumClient,B as w3mConnectors,b as w3mProvider};
